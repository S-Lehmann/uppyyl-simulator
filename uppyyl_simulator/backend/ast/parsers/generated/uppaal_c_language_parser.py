#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import generator_stop

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo
from tatsu.parsing import leftrec, nomemo  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {
    'assign',
    'clock',
    'exists',
    'sync',
    'if',
    'else',
    'return',
    'bool',
    'typedef',
    'before_update',
    'system',
    'process',
    'int',
    'state',
    'forall',
    'const',
    'enum',
    'location',
    'chan',
    'default',
    'broadcast',
    'guard',
    'priority',
    'double',
    'rate',
    'progress',
    'while',
    'after_update',
    'select',
    'commit',
    'scalar',
    'for',
    'continue',
    'meta',
    'invariant',
    'struct',
    'break',
    'switch',
    'void',
    'case',
    'urgent',
    'init',
    'do',
    'trans',
}  # type: ignore


class UppaalCLanguageBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=re.compile('\\s+'),
        nameguard=False,
        comments_re='\\/\\*[\\s\\S]*?\\*\\/',
        eol_comments_re='\\/\\/([^\\n]*?)$',
        ignorecase=False,
        namechars='_-.',
        **kwargs
    ):
        super().__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class UppaalCLanguageParser(Parser):
    def __init__(
        self,
        whitespace=re.compile('\\s+'),
        nameguard=False,
        comments_re='\\/\\*[\\s\\S]*?\\*\\/',
        eol_comments_re='\\/\\/([^\\n]*?)$',
        ignorecase=False,
        left_recursion=False,
        parseinfo=False,
        keywords=None,
        namechars='_-.',
        tokenizercls=UppaalCLanguageBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super().__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            tokenizercls=tokenizercls,
            **kwargs
        )

    @tatsumasu()
    def ___(self):  # noqa
        self._pattern('[ \\t\\r\\n]*')

    @tatsumasu()
    def ____(self):  # noqa
        self._pattern('[ \\t\\r\\n]+')

    @tatsumasu()
    def _UppaalDeclaration_(self):  # noqa
        self.___()
        self._Declarations_()
        self.name_last_node('decls')
        self._constant('UppaalDeclaration')
        self.name_last_node('astType')
        self._check_eof()
        self.ast._define(
            ['astType', 'decls'],
            []
        )

    @tatsumasu()
    def _UppaalSystemDeclaration_(self):  # noqa
        self.___()

        def block1():
            with self._ifnot():
                with self._group():
                    self._token('system')
            with self._group():
                with self._choice():
                    with self._option():
                        self._Declaration_()
                    with self._option():
                        self._Instantiation_()
                    self._error('expecting one of: Declaration Instantiation')
        self._closure(block1)
        self.name_last_node('decls')
        self._System_()
        self.name_last_node('systemDecl')
        self._constant('UppaalSystemDeclaration')
        self.name_last_node('astType')
        self._check_eof()
        self.ast._define(
            ['astType', 'decls', 'systemDecl'],
            []
        )

    @tatsumasu()
    def _Declarations_(self):  # noqa

        def block0():
            self._Declaration_()
        self._closure(block0)

    @tatsumasu()
    def _Declaration_(self):  # noqa
        with self._choice():
            with self._option():
                self._VariableDecls_()
            with self._option():
                self._TypeDecls_()
            with self._option():
                self._Function_()
            with self._option():
                self._ChanPriority_()
            self._error('expecting one of: ChanPriority Function Prefix Type TypeDecls TypeId VariableDecls chan typedef')

    @tatsumasu()
    def _VariableDecls_(self):  # noqa
        self._Type_()
        self.name_last_node('type')

        def sep2():
            self._token(',')

        def block2():
            self._VariableIDInit_()
        self._positive_gather(block2, sep2)
        self.name_last_node('varData')
        self._token(';')
        self._constant('VariableDecls')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'type', 'varData'],
            []
        )

    @tatsumasu()
    def _VariableIDInit_(self):  # noqa
        self._ID_()
        self.name_last_node('varName')

        def block2():
            self._ArrayDecl_()
        self._closure(block2)
        self.name_last_node('arrayDecl')
        with self._optional():
            self._token('=')
            self._Initialiser_()
            self.name_last_node('initData')
        self._constant('VariableID')
        self.name_last_node('astType')
        self.ast._define(
            ['arrayDecl', 'astType', 'initData', 'varName'],
            []
        )

    @tatsumasu()
    def _VariableID_(self):  # noqa
        self._ID_()
        self.name_last_node('varName')

        def block2():
            self._ArrayDecl_()
        self._closure(block2)
        self.name_last_node('arrayDecl')
        self._constant('VariableID')
        self.name_last_node('astType')
        self.ast._define(
            ['arrayDecl', 'astType', 'varName'],
            []
        )

    @tatsumasu()
    def _Initialiser_(self):  # noqa
        with self._choice():
            with self._option():
                self._Expression_()
            with self._option():
                self._InitialiserArray_()
            self._error('expecting one of: ( ++ -- /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ AssignExpr BasicExpression BinaryExpr Boolean BracketExpr Deadlock DerivativeExpr Double Exists Expression ForAll FuncCallExpr ID InitialiserArray Integer Number PostDecrAssignExpr PostIncrAssignExpr PreDecrAssignExpr PreIncrAssignExpr Sum TernaryExpr Unary UnaryExpr Value Variable _ deadlock false true {')

    @tatsumasu()
    def _InitialiserArray_(self):  # noqa
        self._token('{')

        def sep1():
            self._token(',')

        def block1():
            self._Initialiser_()
        self._positive_gather(block1, sep1)
        self.name_last_node('vals')
        self._token('}')
        self._constant('InitialiserArray')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'vals'],
            []
        )

    @tatsumasu()
    def _TypeDecls_(self):  # noqa
        self._token('typedef')
        self._Type_()
        self.name_last_node('type')

        def sep2():
            self._token(',')

        def block2():
            self._VariableID_()
        self._positive_gather(block2, sep2)
        self.name_last_node('names')
        self._token(';')
        self._constant('TypeDecls')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'names', 'type'],
            []
        )

    @tatsumasu()
    def _Type_(self):  # noqa

        def block1():
            self._Prefix_()
        self._closure(block1)
        self.name_last_node('prefixes')
        self._TypeId_()
        self.name_last_node('typeId')
        self._constant('Type')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'prefixes', 'typeId'],
            []
        )

    @tatsumasu()
    def _Prefix_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('urgent')
            with self._option():
                self._token('broadcast')
            with self._option():
                self._token('meta')
            with self._option():
                self._token('const')
            self._error('expecting one of: broadcast const meta urgent')

    @tatsumasu()
    def _BoundedIntType_(self):  # noqa
        self._token('int')
        self._token('[')
        self._Expression_()
        self.name_last_node('lower')
        self._token(',')
        self._Expression_()
        self.name_last_node('upper')
        self._token(']')
        self._constant('BoundedIntType')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'lower', 'upper'],
            []
        )

    @tatsumasu()
    def _ScalarType_(self):  # noqa
        self._token('scalar')
        self._token('[')
        self._Expression_()
        self.name_last_node('expr')
        self._token(']')
        self._constant('ScalarType')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _StructType_(self):  # noqa
        self._token('struct')
        self._token('{')

        def block1():
            self._FieldDecl_()
        self._positive_closure(block1)
        self.name_last_node('fields')
        self._token('}')
        self._constant('StructType')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'fields'],
            []
        )

    @tatsumasu()
    def _TypeId_(self):  # noqa
        with self._choice():
            with self._option():
                self._BoundedIntType_()
            with self._option():
                self._ScalarType_()
            with self._option():
                self._StructType_()
            with self._option():
                self._CustomType_()
            self._error('expecting one of: /[ \\t\\r\\n]*/ BoundedIntType CustomType ScalarType StructType TypeID _ int scalar struct')

    @tatsumasu()
    def _CustomType_(self):  # noqa
        self.___()
        self._TypeID_()
        self.name_last_node('type')
        self._constant('CustomType')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'type'],
            []
        )

    @tatsumasu()
    def _FieldDecl_(self):  # noqa
        self._Type_()
        self.name_last_node('type')

        def sep2():
            self._token(',')

        def block2():
            self._VariableID_()
        self._positive_gather(block2, sep2)
        self.name_last_node('varData')
        self._token(';')
        self._constant('FieldDecl')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'type', 'varData'],
            []
        )

    @tatsumasu()
    def _ArrayDecl_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('[')
                self._Expression_()
                self.name_last_node('@')
                self._token(']')
            with self._option():
                self._token('[')
                self._Type_()
                self.name_last_node('@')
                self._token(']')
            self._error('expecting one of: [')

    @tatsumasu()
    def _Function_(self):  # noqa
        self._Type_()
        self.name_last_node('type')
        self._ID_()
        self.name_last_node('name')
        self._token('(')
        self._Parameters_()
        self.name_last_node('params')
        self._token(')')
        self._Block_()
        self.name_last_node('body')
        self._constant('FunctionDef')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'body', 'name', 'params', 'type'],
            []
        )

    @tatsumasu()
    def _Block_(self):  # noqa
        self._token('{')
        self._Declarations_()
        self.name_last_node('decls')

        def block2():
            self._Statement_()
        self._closure(block2)
        self.name_last_node('stmts')
        self._token('}')
        self._constant('StatementBlock')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'decls', 'stmts'],
            []
        )

    @tatsumasu()
    def _Statement_(self):  # noqa
        with self._choice():
            with self._option():
                self._Block_()
            with self._option():
                self._EmptyStatement_()
            with self._option():
                self._ExprStatement_()
            with self._option():
                self._ForLoop_()
            with self._option():
                self._Iteration_()
            with self._option():
                self._WhileLoop_()
            with self._option():
                self._DoWhileLoop_()
            with self._option():
                self._IfStatement_()
            with self._option():
                self._ReturnStatement_()
            self._error('expecting one of: ; Block DoWhileLoop EmptyStatement ExprStatement Expression ForLoop IfStatement Iteration ReturnStatement WhileLoop do for if return while {')

    @tatsumasu()
    def _EmptyStatement_(self):  # noqa
        self._token(';')
        self._constant('EmptyStatement')
        self.name_last_node('astType')
        self.ast._define(
            ['astType'],
            []
        )

    @tatsumasu()
    def _ExprStatement_(self):  # noqa
        self._Expression_()
        self.name_last_node('expr')
        self._token(';')
        self._constant('ExprStatement')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _ForLoop_(self):  # noqa
        self._token('for')
        self._token('(')
        self._Expression_()
        self.name_last_node('init')
        self._token(';')
        self._Expression_()
        self.name_last_node('cond')
        self._token(';')
        self._Expression_()
        self.name_last_node('after')
        self._token(')')
        self._Statement_()
        self.name_last_node('body')
        self._constant('ForLoop')
        self.name_last_node('astType')
        self.ast._define(
            ['after', 'astType', 'body', 'cond', 'init'],
            []
        )

    @tatsumasu()
    def _Iteration_(self):  # noqa
        self._token('for')
        self._token('(')
        self._ID_()
        self.name_last_node('name')
        self._token(':')
        self._Type_()
        self.name_last_node('type')
        self._token(')')
        self._Statement_()
        self.name_last_node('body')
        self._constant('Iteration')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'body', 'name', 'type'],
            []
        )

    @tatsumasu()
    def _WhileLoop_(self):  # noqa
        self._token('while')
        self._token('(')
        self._Expression_()
        self.name_last_node('cond')
        self._token(')')
        self._Statement_()
        self.name_last_node('body')
        self._constant('WhileLoop')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'body', 'cond'],
            []
        )

    @tatsumasu()
    def _DoWhileLoop_(self):  # noqa
        self._token('do')
        self._Statement_()
        self.name_last_node('body')
        self._token('while')
        self._token('(')
        self._Expression_()
        self.name_last_node('cond')
        self._token(')')
        self._token(';')
        self._constant('DoWhileLoop')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'body', 'cond'],
            []
        )

    @tatsumasu()
    def _IfStatement_(self):  # noqa
        self._token('if')
        self._token('(')
        self._Expression_()
        self.name_last_node('cond')
        self._token(')')
        self._Statement_()
        self.name_last_node('thenBody')
        with self._optional():
            self._token('else')
            self._Statement_()
            self.name_last_node('elseBody')
        self._constant('IfStatement')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'cond', 'elseBody', 'thenBody'],
            []
        )

    @tatsumasu()
    def _ReturnStatement_(self):  # noqa
        self._token('return')
        with self._optional():
            self._Expression_()
            self.name_last_node('expr')
        self._token(';')
        self._constant('ReturnStatement')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _Parameters_(self):  # noqa

        def sep0():
            self._token(',')

        def block0():
            self._Parameter_()
        self._gather(block0, sep0)

    @tatsumasu()
    def _Parameter_(self):  # noqa
        self._Type_()
        self.name_last_node('type')
        with self._optional():
            self._token('&')
            self.name_last_node('isRef')
        self._VariableID_()
        self.name_last_node('varData')
        self._constant('Parameter')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'isRef', 'type', 'varData'],
            []
        )

    @tatsumasu()
    def _System_(self):  # noqa
        self._token('system')

        def sep1():
            self._token('<')

        def block1():

            def sep2():
                self._token(',')

            def block2():
                self._ID_()
            self._positive_gather(block2, sep2)
        self._positive_gather(block1, sep1)
        self.name_last_node('processNames')
        self._token(';')
        self._constant('System')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'processNames'],
            []
        )

    @tatsumasu()
    def _Process_(self):  # noqa
        self._ID_()
        self.name_last_node('name')
        self._token('(')
        self._Arguments_()
        self.name_last_node('args')
        self._token(')')
        self._constant('Process')
        self.name_last_node('astType')
        self.ast._define(
            ['args', 'astType', 'name'],
            []
        )

    @tatsumasu()
    def _Instantiation_(self):  # noqa
        self._ID_()
        self.name_last_node('instanceName')
        with self._optional():
            self._token('(')
            self._Parameters_()
            self.name_last_node('params')
            self._token(')')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('=')
                with self._option():
                    self._token(':=')
                self._error('expecting one of: := =')
        self._ID_()
        self.name_last_node('templateName')
        self._token('(')
        self._Arguments_()
        self.name_last_node('args')
        self._token(')')
        self._token(';')
        self._constant('Instantiation')
        self.name_last_node('astType')
        self.ast._define(
            ['args', 'astType', 'instanceName', 'params', 'templateName'],
            []
        )

    @tatsumasu()
    def _ProgressDecl_(self):  # noqa
        self._token('progress')
        self._token('{')

        def block1():
            self._Expression_()
            self.name_last_node('@')
            self._token(';')
        self._closure(block1)
        self.name_last_node('exprs')
        self._token('}')
        self._constant('ProgressDecl')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'exprs'],
            []
        )

    @tatsumasu()
    def _NonTypeId_(self):  # noqa
        self._ID_()

    @tatsumasu()
    def _GanttDecl_(self):  # noqa
        self._token('gantt {')
        self._GanttDef_()
        self._token('}')
        self._constant('GanttDecl')
        self.name_last_node('astType')
        self.ast._define(
            ['astType'],
            []
        )

    @tatsumasu()
    def _GanttDef_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(' ')
            with self._option():
                self._GanttDef_()
                self._NonTypeId_()
                self._GanttArgs_()
                self._token(':')
                self._GanttExprList_()
                self._token(';')
                self._constant('GanttDef')
                self.name_last_node('astType')
            self._error('expecting one of:   GanttDef')
        self.ast._define(
            ['astType'],
            []
        )

    @tatsumasu()
    def _GanttArgs_(self):  # noqa
        with self._choice():
            with self._option():
                self._token(' ')
            with self._option():
                self._token('(')
                self._GanttDeclSelect_()
                self._token(')')
                self._constant('GanttArgs')
                self.name_last_node('astType')
            self._error('expecting one of:   (')
        self.ast._define(
            ['astType'],
            []
        )

    @tatsumasu()
    def _GanttEntryElem_(self):  # noqa
        self._ID_()
        self.name_last_node('id')
        self._token(':')
        self._Type_()
        self.name_last_node('type')
        self._constant('GanttEntryElem')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'id', 'type'],
            []
        )

    @tatsumasu()
    def _GanttDeclSelect_(self):  # noqa

        def sep1():
            self._token(',')

        def block1():
            self._GanttEntryElem_()
        self._positive_gather(block1, sep1)
        self.name_last_node('selects')
        self._constant('GanttDeclSelect')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'selects'],
            []
        )

    @tatsumasu()
    def _GanttExprList_(self):  # noqa

        def sep0():
            self._token(',')

        def block0():
            self._GanttExpr_()
        self._positive_gather(block0, sep0)
        self._constant('GanttExprList')
        self.name_last_node('astType')
        self.ast._define(
            ['astType'],
            []
        )

    @tatsumasu()
    def _GantExprSingle_(self):  # noqa
        self._Expression_()
        self.name_last_node('cond')
        self._token('->')
        self._Expression_()
        self.name_last_node('intExpr')
        self._constant('GantExprSingle')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'cond', 'intExpr'],
            []
        )

    @tatsumasu()
    def _GanttExprSelect_(self):  # noqa
        self._token('for (')
        self._GanttEntrySelect_()
        self.name_last_node('entrySelect')
        self._token(')')
        self._Expression_()
        self.name_last_node('cond')
        self._token('->')
        self._Expression_()
        self.name_last_node('intExpr')
        self._constant('GanttExprSelect')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'cond', 'entrySelect', 'intExpr'],
            []
        )

    @tatsumasu()
    def _GanttExpr_(self):  # noqa
        with self._choice():
            with self._option():
                self._GantExprSingle_()
            with self._option():
                self._GanttExprSelect_()
            self._error('expecting one of: ( ++ -- /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ AssignExpr BasicExpression BinaryExpr Boolean BracketExpr Deadlock DerivativeExpr Double Exists Expression ForAll FuncCallExpr GantExprSingle GanttExprSelect ID Integer Number PostDecrAssignExpr PostIncrAssignExpr PreDecrAssignExpr PreIncrAssignExpr Sum TernaryExpr Unary UnaryExpr Value Variable _ deadlock false for ( true')

    @tatsumasu()
    def _GanttEntrySelect_(self):  # noqa

        def sep1():
            self._token(',')

        def block1():
            self._GanttEntryElem_()
        self._positive_gather(block1, sep1)
        self.name_last_node('selects')
        self._constant('GanttEntrySelect')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'selects'],
            []
        )

    @tatsumasu()
    def _ChanPriority_(self):  # noqa
        self._token('chan')
        self._token('priority')

        def sep1():
            self._token('<')

        def block1():

            def sep2():
                self._token(',')

            def block2():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._ChanExpr_()
                        with self._option():
                            self._token('default')
                        self._error('expecting one of: ChanExpr default')
            self._positive_gather(block2, sep2)
        self._positive_gather(block1, sep1)
        self.name_last_node('channels')
        self._token(';')
        self._constant('ChanPriority')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'channels'],
            []
        )

    @tatsumasu()
    def _ChanExpr_(self):  # noqa
        self._ID_()
        self.name_last_node('name')

        def block2():
            self._VariableIndex_()
        self._closure(block2)
        self.name_last_node('indices')
        self._constant('ChanExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'indices', 'name'],
            []
        )

    @tatsumasu()
    def _ChanDefault_(self):  # noqa
        self._token('default')
        self._constant('ChanDefault')
        self.name_last_node('astType')
        self.ast._define(
            ['astType'],
            []
        )

    @tatsumasu()
    def _VariableIndex_(self):  # noqa
        self._token('[')
        self._Expression_()
        self.name_last_node('@')
        self._token(']')

    @tatsumasu()
    def _Variable_(self):  # noqa
        self._ID_()
        self.name_last_node('name')

        def block2():
            self._VariableIndex_()
        self._closure(block2)
        self.name_last_node('indices')
        self._constant('Variable')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'indices', 'name'],
            []
        )

    @tatsumasu()
    def _Integer_(self):  # noqa
        self.___()
        self._pattern('[-+]?[0-9]+')
        self.name_last_node('val')
        self._constant('Integer')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'val'],
            []
        )

    @tatsumasu()
    def _Double_(self):  # noqa
        self.___()
        self._pattern('[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?')
        self.name_last_node('val')
        self._constant('Double')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'val'],
            []
        )

    @tatsumasu()
    def _Boolean_(self):  # noqa
        self.___()
        with self._group():
            with self._choice():
                with self._option():
                    self._token('true')
                with self._option():
                    self._token('false')
                self._error('expecting one of: false true')
        self.name_last_node('val')
        self._constant('Boolean')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'val'],
            []
        )

    @tatsumasu()
    def _Number_(self):  # noqa
        with self._choice():
            with self._option():
                self._Double_()
            with self._option():
                self._Integer_()
            self._error('expecting one of: /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ Double Integer _')

    @tatsumasu()
    def _Value_(self):  # noqa
        with self._choice():
            with self._option():
                self._Number_()
            with self._option():
                self._Boolean_()
            self._error('expecting one of: /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ Boolean Double Integer Number _ false true')

    @tatsumasu()
    def _ID_(self):  # noqa
        self.___()
        with self._ifnot():
            with self._group():
                self._ReservedKeywords_()
                self._pattern('[^a-zA-Z0-9_]+')
        self._pattern('[a-zA-Z_][a-zA-Z0-9_]*')
        self.name_last_node('@')

    @tatsumasu()
    def _TypeID_(self):  # noqa
        self.___()
        with self._ifnot():
            with self._group():
                self._ReservedNonTypeKeywords_()
                self._pattern('[^a-zA-Z0-9_]+')
        self._pattern('[a-zA-Z_][a-zA-Z0-9_]*')
        self.name_last_node('@')

    @tatsumasu()
    def _BracketExpr_(self):  # noqa
        self._token('(')
        self._Expression_()
        self.name_last_node('expr')
        self._token(')')
        self._constant('BracketExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _DerivativeExpr_(self):  # noqa
        self._Variable_()
        self.name_last_node('expr')
        self._token("'")
        self._constant('DerivativeExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _PostIncrAssignExpr_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._Number_()
                with self._option():
                    self._Variable_()
                with self._option():
                    self._BracketExpr_()
                self._error('expecting one of: BracketExpr Number Variable')
        self.name_last_node('expr')
        self._token('++')
        self._constant('PostIncrAssignExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _PostDecrAssignExpr_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._Number_()
                with self._option():
                    self._Variable_()
                with self._option():
                    self._BracketExpr_()
                self._error('expecting one of: BracketExpr Number Variable')
        self.name_last_node('expr')
        self._token('--')
        self._constant('PostDecrAssignExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _PreIncrAssignExpr_(self):  # noqa
        self._token('++')
        with self._group():
            with self._choice():
                with self._option():
                    self._Number_()
                with self._option():
                    self._Variable_()
                with self._option():
                    self._Expression_()
                self._error('expecting one of: Expression Number Variable')
        self.name_last_node('expr')
        self._constant('PreIncrAssignExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _PreDecrAssignExpr_(self):  # noqa
        self._token('--')
        with self._group():
            with self._choice():
                with self._option():
                    self._Number_()
                with self._option():
                    self._Variable_()
                with self._option():
                    self._Expression_()
                self._error('expecting one of: Expression Number Variable')
        self.name_last_node('expr')
        self._constant('PreDecrAssignExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _AssignExpr_(self):  # noqa
        self._Variable_()
        self.name_last_node('left')
        self._Assign_()
        self.name_last_node('op')
        self._Expression_()
        self.name_last_node('right')
        self._constant('AssignExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _FuncCallExpr_(self):  # noqa
        self._ID_()
        self.name_last_node('funcName')
        self._token('(')
        self._Arguments_()
        self.name_last_node('args')
        self._token(')')
        self._constant('FuncCallExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['args', 'astType', 'funcName'],
            []
        )

    @tatsumasu()
    def _UnaryExpr_(self):  # noqa
        self._Unary_()
        self.name_last_node('op')
        self._Expression_()
        self.name_last_node('expr')
        self._constant('UnaryExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr', 'op'],
            []
        )

    @tatsumasu()
    def _BinaryExpr_(self):  # noqa
        self._BasicExpression_()
        self.name_last_node('left')
        self._Binary_()
        self.name_last_node('op')
        self._Expression_()
        self.name_last_node('right')
        self._constant('BinaryExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _TernaryExpr_(self):  # noqa
        self._BasicExpression_()
        self.name_last_node('left')
        self._token('?')
        self._Expression_()
        self.name_last_node('middle')
        self._token(':')
        self._Expression_()
        self.name_last_node('right')
        self._constant('Ternary')
        self.name_last_node('op')
        self._constant('TernaryExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'left', 'middle', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _Deadlock_(self):  # noqa
        self._token('deadlock')
        self._constant('DeadlockExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType'],
            []
        )

    @tatsumasu()
    def _BasicExpression_(self):  # noqa
        with self._choice():
            with self._option():
                self._BracketExpr_()
            with self._option():
                self._ForAll_()
            with self._option():
                self._Exists_()
            with self._option():
                self._Sum_()
            with self._option():
                self._DerivativeExpr_()
            with self._option():
                self._PostIncrAssignExpr_()
            with self._option():
                self._PostDecrAssignExpr_()
            with self._option():
                self._PreIncrAssignExpr_()
            with self._option():
                self._PreDecrAssignExpr_()
            with self._option():
                self._UnaryExpr_()
            with self._option():
                self._AssignExpr_()
            with self._option():
                self._FuncCallExpr_()
            with self._option():
                self._Deadlock_()
            with self._option():
                self._Value_()
            with self._option():
                self._Variable_()
            self._error('expecting one of: ! ( + ++ - -- /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ AssignExpr Boolean BracketExpr Deadlock DerivativeExpr Double Exists ForAll FuncCallExpr ID Integer Number PostDecrAssignExpr PostIncrAssignExpr PreDecrAssignExpr PreIncrAssignExpr Sum Unary UnaryExpr Value Variable _ deadlock exists false forall not sum true')

    @tatsumasu()
    def _Expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._TernaryExpr_()
            with self._option():
                self._BinaryExpr_()
            with self._option():
                self._BasicExpression_()
            self._error('expecting one of: ! ( + ++ - -- /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ AssignExpr BasicExpression BinaryExpr Boolean BracketExpr Deadlock DerivativeExpr Double Exists ForAll FuncCallExpr ID Integer Number PostDecrAssignExpr PostIncrAssignExpr PreDecrAssignExpr PreIncrAssignExpr Sum TernaryExpr Unary UnaryExpr Value Variable _ deadlock exists false forall not sum true')

    @tatsumasu()
    def _Arguments_(self):  # noqa

        def sep0():
            self._token(',')

        def block0():
            self._Expression_()
        self._gather(block0, sep0)

    @tatsumasu()
    def _Assign_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('=')
                self._constant('Assign')
                self.name_last_node('@')
            with self._option():
                self._token(':=')
                self._constant('Assign')
                self.name_last_node('@')
            with self._option():
                self._token('+=')
                self._constant('AddAssign')
                self.name_last_node('@')
            with self._option():
                self._token('-=')
                self._constant('SubAssign')
                self.name_last_node('@')
            with self._option():
                self._token('*=')
                self._constant('MultAssign')
                self.name_last_node('@')
            with self._option():
                self._token('/=')
                self._constant('DivAssign')
                self.name_last_node('@')
            with self._option():
                self._token('%=')
                self._constant('ModAssign')
                self.name_last_node('@')
            with self._option():
                self._token('|=')
                self._constant('BitOrAssign')
                self.name_last_node('@')
            with self._option():
                self._token('&=')
                self._constant('BitAndAssign')
                self.name_last_node('@')
            with self._option():
                self._token('^=')
                self._constant('BitXorAssign')
                self.name_last_node('@')
            with self._option():
                self._token('<<=')
                self._constant('LShiftAssign')
                self.name_last_node('@')
            with self._option():
                self._token('>>=')
                self._constant('RShiftAssign')
                self.name_last_node('@')
            self._error('expecting one of: %= &= *= += -= /= := <<= = >>= ^= |=')

    @tatsumasu()
    def _Unary_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('!')
                self._constant('LogNot')
                self.name_last_node('@')
            with self._option():
                self._token('not')
                self._constant('LogNot')
                self.name_last_node('@')
            with self._option():
                self._token('+')
                self._constant('Plus')
                self.name_last_node('@')
            with self._option():
                self._token('-')
                self._constant('Minus')
                self.name_last_node('@')
            self._error('expecting one of: ! + - not')

    @tatsumasu()
    def _Binary_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('<<')
                self._constant('LShift')
                self.name_last_node('@')
            with self._option():
                self._token('>>')
                self._constant('RShift')
                self.name_last_node('@')
            with self._option():
                self._token('&&')
                self._constant('LogAnd')
                self.name_last_node('@')
            with self._option():
                self._token('and')
                self._constant('LogAnd')
                self.name_last_node('@')
            with self._option():
                self._token('||')
                self._constant('LogOr')
                self.name_last_node('@')
            with self._option():
                self._token('or')
                self._constant('LogOr')
                self.name_last_node('@')
            with self._option():
                self._token('imply')
                self._constant('LogImply')
                self.name_last_node('@')
            with self._option():
                self._token('&')
                self._constant('BitAnd')
                self.name_last_node('@')
            with self._option():
                self._token('|')
                self._constant('BitOr')
                self.name_last_node('@')
            with self._option():
                self._token('^')
                self._constant('BitXor')
                self.name_last_node('@')
            with self._option():
                self._token('<?')
                self._constant('Minimum')
                self.name_last_node('@')
            with self._option():
                self._token('>?')
                self._constant('Maximum')
                self.name_last_node('@')
            with self._option():
                self._token('<=')
                self._constant('LessEqual')
                self.name_last_node('@')
            with self._option():
                self._token('<')
                self._constant('LessThan')
                self.name_last_node('@')
            with self._option():
                self._token('==')
                self._constant('Equal')
                self.name_last_node('@')
            with self._option():
                self._token('!=')
                self._constant('NotEqual')
                self.name_last_node('@')
            with self._option():
                self._token('>=')
                self._constant('GreaterEqual')
                self.name_last_node('@')
            with self._option():
                self._token('>')
                self._constant('GreaterThan')
                self.name_last_node('@')
            with self._option():
                self._token('+')
                self._constant('Add')
                self.name_last_node('@')
            with self._option():
                self._token('-')
                self._constant('Sub')
                self.name_last_node('@')
            with self._option():
                self._token('*')
                self._constant('Mult')
                self.name_last_node('@')
            with self._option():
                self._token('/')
                self._constant('Div')
                self.name_last_node('@')
            with self._option():
                self._token('%')
                self._constant('Mod')
                self.name_last_node('@')
            with self._option():
                self._token('.')
                self._constant('Dot')
                self.name_last_node('@')
            self._error('expecting one of: != % & && * + - . / < << <= <? == > >= >> >? ^ and imply or | ||')

    @tatsumasu()
    def _ForAll_(self):  # noqa
        self._token('forall')
        self._token('(')
        self._ID_()
        self.name_last_node('varName')
        self._token(':')
        self._Type_()
        self.name_last_node('type')
        self._token(')')
        self._Expression_()
        self.name_last_node('expr')
        self._constant('ForAllExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr', 'type', 'varName'],
            []
        )

    @tatsumasu()
    def _Exists_(self):  # noqa
        self._token('exists')
        self._token('(')
        self._ID_()
        self.name_last_node('varName')
        self._token(':')
        self._Type_()
        self.name_last_node('type')
        self._token(')')
        self._Expression_()
        self.name_last_node('expr')
        self._constant('ExistsExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr', 'type', 'varName'],
            []
        )

    @tatsumasu()
    def _Sum_(self):  # noqa
        self._token('sum')
        self._token('(')
        self._ID_()
        self.name_last_node('varName')
        self._token(':')
        self._Type_()
        self.name_last_node('type')
        self._token(')')
        self._Expression_()
        self.name_last_node('expr')
        self._constant('SumExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr', 'type', 'varName'],
            []
        )

    @tatsumasu()
    def _ReservedTypeKeywords_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('chan')
            with self._option():
                self._token('clock')
            with self._option():
                self._token('double')
            with self._option():
                self._token('bool')
            with self._option():
                self._token('int')
            with self._option():
                self._token('scalar')
            with self._option():
                self._token('struct')
            with self._option():
                self._token('void')
            with self._option():
                self._token('typedef')
            self._error('expecting one of: bool chan clock double int scalar struct typedef void')

    @tatsumasu()
    def _ReservedQualKeywords_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('commit')
            with self._option():
                self._token('const')
            with self._option():
                self._token('urgent')
            with self._option():
                self._token('broadcast')
            with self._option():
                self._token('meta')
            with self._option():
                self._token('init')
            self._error('expecting one of: broadcast commit const init meta urgent')

    @tatsumasu()
    def _ReservedExprKeywords_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('and')
            with self._option():
                self._token('or')
            with self._option():
                self._token('not')
            with self._option():
                self._token('imply')
            with self._option():
                self._token('true')
            with self._option():
                self._token('false')
            with self._option():
                self._token('forall')
            with self._option():
                self._token('exists')
            self._error('expecting one of: and exists false forall imply not or true')

    @tatsumasu()
    def _ReservedStmtKeywords_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('while')
            with self._option():
                self._token('do')
            with self._option():
                self._token('if')
            with self._option():
                self._token('else')
            with self._option():
                self._token('return')
            with self._option():
                self._token('for')
            self._error('expecting one of: do else for if return while')

    @tatsumasu()
    def _ReservedOtherKeywords_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('deadlock')
            with self._option():
                self._token('process')
            with self._option():
                self._token('state')
            with self._option():
                self._token('invariant')
            with self._option():
                self._token('guard')
            with self._option():
                self._token('sync')
            with self._option():
                self._token('assign')
            with self._option():
                self._token('select')
            with self._option():
                self._token('before_update')
            with self._option():
                self._token('after_update')
            with self._option():
                self._token('location')
            with self._option():
                self._token('system')
            with self._option():
                self._token('trans')
            with self._option():
                self._token('rate')
            with self._option():
                self._token('priority')
            with self._option():
                self._token('progress')
            with self._option():
                self._token('default')
            self._error('expecting one of: after_update assign before_update deadlock default guard invariant location priority process progress rate select state sync system trans')

    @tatsumasu()
    def _ReservedFutureKeywords_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('switch')
            with self._option():
                self._token('case')
            with self._option():
                self._token('continue')
            with self._option():
                self._token('break')
            with self._option():
                self._token('enum')
            self._error('expecting one of: break case continue enum switch')

    @tatsumasu()
    def _ReservedNonTypeKeywords_(self):  # noqa
        with self._choice():
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('commit')
                    with self._option():
                        self._token('const')
                    with self._option():
                        self._token('urgent')
                    with self._option():
                        self._token('broadcast')
                    with self._option():
                        self._token('meta')
                    with self._option():
                        self._token('init')
                    self._error('expecting one of: broadcast commit const init meta urgent')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('and')
                    with self._option():
                        self._token('or')
                    with self._option():
                        self._token('not')
                    with self._option():
                        self._token('imply')
                    with self._option():
                        self._token('true')
                    with self._option():
                        self._token('false')
                    with self._option():
                        self._token('forall')
                    with self._option():
                        self._token('exists')
                    self._error('expecting one of: and exists false forall imply not or true')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('while')
                    with self._option():
                        self._token('do')
                    with self._option():
                        self._token('if')
                    with self._option():
                        self._token('else')
                    with self._option():
                        self._token('return')
                    with self._option():
                        self._token('for')
                    self._error('expecting one of: do else for if return while')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('deadlock')
                    with self._option():
                        self._token('process')
                    with self._option():
                        self._token('state')
                    with self._option():
                        self._token('invariant')
                    with self._option():
                        self._token('guard')
                    with self._option():
                        self._token('sync')
                    with self._option():
                        self._token('assign')
                    with self._option():
                        self._token('select')
                    with self._option():
                        self._token('before_update')
                    with self._option():
                        self._token('after_update')
                    with self._option():
                        self._token('location')
                    with self._option():
                        self._token('system')
                    with self._option():
                        self._token('trans')
                    with self._option():
                        self._token('rate')
                    with self._option():
                        self._token('priority')
                    with self._option():
                        self._token('progress')
                    with self._option():
                        self._token('default')
                    self._error('expecting one of: after_update assign before_update deadlock default guard invariant location priority process progress rate select state sync system trans')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('switch')
                    with self._option():
                        self._token('case')
                    with self._option():
                        self._token('continue')
                    with self._option():
                        self._token('break')
                    with self._option():
                        self._token('enum')
                    self._error('expecting one of: break case continue enum switch')
            self._error('expecting one of: after_update and assign before_update break broadcast case commit const continue deadlock default do else enum exists false for forall guard if imply init invariant location meta not or priority process progress rate return select state switch sync system trans true urgent while')

    @tatsumasu()
    def _ReservedKeywords_(self):  # noqa
        with self._choice():
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('commit')
                    with self._option():
                        self._token('const')
                    with self._option():
                        self._token('urgent')
                    with self._option():
                        self._token('broadcast')
                    with self._option():
                        self._token('meta')
                    with self._option():
                        self._token('init')
                    self._error('expecting one of: broadcast commit const init meta urgent')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('and')
                    with self._option():
                        self._token('or')
                    with self._option():
                        self._token('not')
                    with self._option():
                        self._token('imply')
                    with self._option():
                        self._token('true')
                    with self._option():
                        self._token('false')
                    with self._option():
                        self._token('forall')
                    with self._option():
                        self._token('exists')
                    self._error('expecting one of: and exists false forall imply not or true')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('while')
                    with self._option():
                        self._token('do')
                    with self._option():
                        self._token('if')
                    with self._option():
                        self._token('else')
                    with self._option():
                        self._token('return')
                    with self._option():
                        self._token('for')
                    self._error('expecting one of: do else for if return while')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('deadlock')
                    with self._option():
                        self._token('process')
                    with self._option():
                        self._token('state')
                    with self._option():
                        self._token('invariant')
                    with self._option():
                        self._token('guard')
                    with self._option():
                        self._token('sync')
                    with self._option():
                        self._token('assign')
                    with self._option():
                        self._token('select')
                    with self._option():
                        self._token('before_update')
                    with self._option():
                        self._token('after_update')
                    with self._option():
                        self._token('location')
                    with self._option():
                        self._token('system')
                    with self._option():
                        self._token('trans')
                    with self._option():
                        self._token('rate')
                    with self._option():
                        self._token('priority')
                    with self._option():
                        self._token('progress')
                    with self._option():
                        self._token('default')
                    self._error('expecting one of: after_update assign before_update deadlock default guard invariant location priority process progress rate select state sync system trans')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('switch')
                    with self._option():
                        self._token('case')
                    with self._option():
                        self._token('continue')
                    with self._option():
                        self._token('break')
                    with self._option():
                        self._token('enum')
                    self._error('expecting one of: break case continue enum switch')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('chan')
                    with self._option():
                        self._token('clock')
                    with self._option():
                        self._token('double')
                    with self._option():
                        self._token('bool')
                    with self._option():
                        self._token('int')
                    with self._option():
                        self._token('scalar')
                    with self._option():
                        self._token('struct')
                    with self._option():
                        self._token('void')
                    with self._option():
                        self._token('typedef')
                    self._error('expecting one of: bool chan clock double int scalar struct typedef void')
            self._error('expecting one of: after_update and assign before_update bool break broadcast case chan clock commit const continue deadlock default do double else enum exists false for forall guard if imply init int invariant location meta not or priority process progress rate return scalar select state struct switch sync system trans true typedef urgent void while')

    @tatsumasu()
    def _Invariant_(self):  # noqa
        self._Expression_()
        self.name_last_node('expr')
        self._constant('Invariant')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _Invariants_(self):  # noqa
        self._Invariant_()

    @tatsumasu()
    def _Select_(self):  # noqa
        self._ID_()
        self.name_last_node('name')
        self._token(':')
        self._Type_()
        self.name_last_node('type')
        self._constant('Select')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'name', 'type'],
            []
        )

    @tatsumasu()
    def _Selects_(self):  # noqa

        def sep0():
            self._token(',')

        def block0():
            self._Select_()
        self._gather(block0, sep0)

    @tatsumasu()
    def _Guard_(self):  # noqa
        self._Expression_()
        self.name_last_node('expr')
        self._constant('Guard')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _Guards_(self):  # noqa
        self._Guard_()

    @tatsumasu()
    def _Sync_(self):  # noqa
        self._Variable_()
        self.name_last_node('channel')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('!')
                with self._option():
                    self._token('?')
                self._error('expecting one of: ! ?')
        self.name_last_node('op')
        self._constant('Sync')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'channel', 'op'],
            []
        )

    @tatsumasu()
    def _Update_(self):  # noqa
        self._Expression_()
        self.name_last_node('expr')
        self._constant('Update')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _Updates_(self):  # noqa

        def sep0():
            self._token(',')

        def block0():
            self._Update_()
        self._gather(block0, sep0)

    @tatsumasu()
    def _QBracketExpr_(self):  # noqa
        self._token('(')
        self._QExpression_()
        self.name_last_node('expr')
        self._token(')')
        self._constant('BracketExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _QFuncCallExpr_(self):  # noqa
        self._ID_()
        self.name_last_node('funcName')
        self._token('(')
        self._Arguments_()
        self.name_last_node('args')
        self._token(')')
        self._constant('FuncCallExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['args', 'astType', 'funcName'],
            []
        )

    @tatsumasu()
    def _QUnaryExpr_(self):  # noqa
        self._Unary_()
        self.name_last_node('op')
        self._QExpression_()
        self.name_last_node('expr')
        self._constant('UnaryExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr', 'op'],
            []
        )

    @tatsumasu()
    def _QBinaryExpr_(self):  # noqa
        self._QBasicExpression_()
        self.name_last_node('left')
        self._Binary_()
        self.name_last_node('op')
        self._QExpression_()
        self.name_last_node('right')
        self._constant('BinaryExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _QTernaryExpr_(self):  # noqa
        self._QBasicExpression_()
        self.name_last_node('left')
        self._token('?')
        self._QExpression_()
        self.name_last_node('middle')
        self._token(':')
        self._QExpression_()
        self.name_last_node('right')
        self._constant('Ternary')
        self.name_last_node('op')
        self._constant('TernaryExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'left', 'middle', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _QDeadlock_(self):  # noqa
        self._token('deadlock')
        self._constant('DeadlockExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType'],
            []
        )

    @tatsumasu()
    def _QForAll_(self):  # noqa
        self._token('forall')
        self._token('(')
        self._ID_()
        self.name_last_node('varName')
        self._token(':')
        self._Type_()
        self.name_last_node('type')
        self._token(')')
        self._QExpression_()
        self.name_last_node('expr')
        self._constant('ForAllExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr', 'type', 'varName'],
            []
        )

    @tatsumasu()
    def _QExists_(self):  # noqa
        self._token('exists')
        self._token('(')
        self._ID_()
        self.name_last_node('varName')
        self._token(':')
        self._Type_()
        self.name_last_node('type')
        self._token(')')
        self._QExpression_()
        self.name_last_node('expr')
        self._constant('ExistsExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr', 'type', 'varName'],
            []
        )

    @tatsumasu()
    def _QSum_(self):  # noqa
        self._token('sum')
        self._token('(')
        self._ID_()
        self.name_last_node('varName')
        self._token(':')
        self._Type_()
        self.name_last_node('type')
        self._token(')')
        self._QExpression_()
        self.name_last_node('expr')
        self._constant('SumExpr')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr', 'type', 'varName'],
            []
        )

    @tatsumasu()
    def _QBasicExpression_(self):  # noqa
        with self._choice():
            with self._option():
                self._QBracketExpr_()
            with self._option():
                self._QForAll_()
            with self._option():
                self._QExists_()
            with self._option():
                self._QSum_()
            with self._option():
                self._QUnaryExpr_()
            with self._option():
                self._QFuncCallExpr_()
            with self._option():
                self._QDeadlock_()
            with self._option():
                self._Value_()
            with self._option():
                self._Variable_()
            self._error('expecting one of: ! ( + - /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ Boolean Double ID Integer Number QBracketExpr QDeadlock QExists QForAll QFuncCallExpr QSum QUnaryExpr Unary Value Variable _ deadlock exists false forall not sum true')

    @tatsumasu()
    def _QExpression_(self):  # noqa
        with self._choice():
            with self._option():
                self._QTernaryExpr_()
            with self._option():
                self._QBinaryExpr_()
            with self._option():
                self._QBasicExpression_()
            self._error('expecting one of: ! ( + - /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ Boolean Double ID Integer Number QBasicExpression QBinaryExpr QBracketExpr QDeadlock QExists QForAll QFuncCallExpr QSum QTernaryExpr QUnaryExpr Unary Value Variable _ deadlock exists false forall not sum true')

    @tatsumasu()
    def _Predicate_(self):  # noqa
        self._QExpression_()
        self.name_last_node('expr')
        self._constant('Predicate')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr'],
            []
        )

    @tatsumasu()
    def _PropAll_(self):  # noqa
        self._token('A')
        self._PropPathSpecQuant_()
        self.name_last_node('prop')
        self._constant('PropAll')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'prop'],
            []
        )

    @tatsumasu()
    def _PropExists_(self):  # noqa
        self._token('E')
        self._PropPathSpecQuant_()
        self.name_last_node('prop')
        self._constant('PropExists')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'prop'],
            []
        )

    @tatsumasu()
    def _PropLeadsTo_(self):  # noqa
        self._Predicate_()
        self.name_last_node('left')
        self._token('-->')
        self._Predicate_()
        self.name_last_node('right')
        self._constant('PropLeadsTo')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'left', 'right'],
            []
        )

    @tatsumasu()
    def _PropPathQuant_(self):  # noqa
        with self._choice():
            with self._option():
                self._PropAll_()
            with self._option():
                self._PropExists_()
            with self._option():
                self._PropLeadsTo_()
            self._error('expecting one of: ! ( + - /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ A Boolean Double E ID Integer Number Predicate PropAll PropExists PropLeadsTo QBasicExpression QBinaryExpr QBracketExpr QDeadlock QExists QExpression QForAll QFuncCallExpr QSum QTernaryExpr QUnaryExpr Unary Value Variable _ deadlock exists false forall not sum true')

    @tatsumasu()
    def _PropGlobally_(self):  # noqa
        self._token('[]')
        self._Predicate_()
        self.name_last_node('prop')
        self._constant('PropGlobally')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'prop'],
            []
        )

    @tatsumasu()
    def _PropFinally_(self):  # noqa
        self._token('<>')
        self._Predicate_()
        self.name_last_node('prop')
        self._constant('PropFinally')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'prop'],
            []
        )

    @tatsumasu()
    def _PropUntil_(self):  # noqa
        self._Predicate_()
        self.name_last_node('left')
        self._token('U')
        self._Predicate_()
        self.name_last_node('right')
        self._constant('PropUntil')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'left', 'right'],
            []
        )

    @tatsumasu()
    def _PropPathSpecQuant_(self):  # noqa
        with self._choice():
            with self._option():
                self._PropGlobally_()
            with self._option():
                self._PropFinally_()
            with self._option():
                self._PropUntil_()
            self._error('expecting one of: ! ( + - /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ <> Boolean Double ID Integer Number Predicate PropFinally PropGlobally PropUntil QBasicExpression QBinaryExpr QBracketExpr QDeadlock QExists QExpression QForAll QFuncCallExpr QSum QTernaryExpr QUnaryExpr Unary Value Variable [] _ deadlock exists false forall not sum true')

    @tatsumasu()
    def _SupInf_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token('inf')
                with self._option():
                    self._token('sup')
                self._error('expecting one of: inf sup')
        self.name_last_node('type')
        with self._optional():
            self._token('{')
            self._Predicate_()
            self.name_last_node('predicate')
            self._token('}')
        self._token(':')

        def sep4():
            self._token(',')

        def block4():
            self._QExpression_()
        self._positive_gather(block4, sep4)
        self.name_last_node('exprs')
        self._constant('PropValBounds')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'exprs', 'predicate', 'type'],
            []
        )

    @tatsumasu()
    def _TimeBound_(self):  # noqa
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._Clock_()
                    with self._option():
                        self._token('#')
                    self._error('expecting one of: # Clock')
            self.name_last_node('var')
        self._token('<=')
        self._CONST_()
        self.name_last_node('upperBound')
        self._constant('PropTimeBound')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'upperBound', 'var'],
            []
        )

    @tatsumasu()
    def _Sim_(self):  # noqa
        self._token('simulate')
        self._CONST_()
        self.name_last_node('runCount')
        self._token('[')
        self._TimeBound_()
        self.name_last_node('timeBound')
        self._token(']')
        self._token('{')
        with self._group():

            def sep3():
                self._token(',')

            def block3():
                self._QExpression_()
            self._positive_gather(block3, sep3)
        self.name_last_node('obsVars')
        self._token('}')
        self._constant('PropSMCSim')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'obsVars', 'runCount', 'timeBound'],
            []
        )

    @tatsumasu()
    def _SimAcceptRuns_(self):  # noqa
        self._Sim_()
        self.name_last_node('simulate')
        self._token(':')
        self._CONST_()
        self.name_last_node('acceptBound')
        self._token(':')
        self._token('(')
        self._Predicate_()
        self.name_last_node('predicate')
        self._token(')')
        self._constant('PropSMCSimAcceptRuns')
        self.name_last_node('astType')
        self.ast._define(
            ['acceptBound', 'astType', 'predicate', 'simulate'],
            []
        )

    @tatsumasu()
    def _ProbEstimate_(self):  # noqa
        self._token('Pr')
        self._token('[')
        self._TimeBound_()
        self.name_last_node('timeBound')
        self._token(']')
        self._token('(')
        self._PropPathSpecQuant_()
        self.name_last_node('prop')
        self._token(')')
        self._constant('PropSMCProbEstimate')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'prop', 'timeBound'],
            []
        )

    @tatsumasu()
    def _HypothesisTest_(self):  # noqa
        self._ProbEstimate_()
        self.name_last_node('prop')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('<=')
                with self._option():
                    self._token('>=')
                self._error('expecting one of: <= >=')
        self.name_last_node('op')
        self._PROB_()
        self.name_last_node('probVal')
        self._constant('PropSMCHypothesisTest')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'op', 'probVal', 'prop'],
            []
        )

    @tatsumasu()
    def _ProbCompare_(self):  # noqa
        self._ProbEstimate_()
        self.name_last_node('left')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('<=')
                with self._option():
                    self._token('>=')
                self._error('expecting one of: <= >=')
        self.name_last_node('op')
        self._ProbEstimate_()
        self.name_last_node('right')
        self._constant('PropSMCProbCompare')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _ValueEstimate_(self):  # noqa
        self._token('E[')
        self._TimeBound_()
        self.name_last_node('timeBound')
        self._token(';')
        self._CONST_()
        self.name_last_node('runCount')
        self._token(']')
        self._token('(')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('min')
                with self._option():
                    self._token('max')
                self._error('expecting one of: max min')
        self.name_last_node('op')
        self._token(':')
        self._QExpression_()
        self.name_last_node('expr')
        self._token(')')
        self._constant('PropSMCValueEstimate')
        self.name_last_node('astType')
        self.ast._define(
            ['astType', 'expr', 'op', 'runCount', 'timeBound'],
            []
        )

    @tatsumasu()
    def _UppaalTCTLProp_(self):  # noqa
        with self._choice():
            with self._option():
                self._PropPathQuant_()
            with self._option():
                self._SupInf_()
            self._error('expecting one of: ! ( + - /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ A Boolean Double E ID Integer Number Predicate PropAll PropExists PropLeadsTo PropPathQuant QBasicExpression QBinaryExpr QBracketExpr QDeadlock QExists QExpression QForAll QFuncCallExpr QSum QTernaryExpr QUnaryExpr SupInf Unary Value Variable _ deadlock exists false forall inf not sum sup true')

    @tatsumasu()
    def _UppaalSMCProp_(self):  # noqa
        with self._choice():
            with self._option():
                self._SimAcceptRuns_()
            with self._option():
                self._Sim_()
            with self._option():
                self._ProbCompare_()
            with self._option():
                self._HypothesisTest_()
            with self._option():
                self._ProbEstimate_()
            with self._option():
                self._ValueEstimate_()
            self._error('expecting one of: E[ HypothesisTest Pr ProbCompare ProbEstimate Sim SimAcceptRuns ValueEstimate simulate')

    @tatsumasu()
    def _UppaalProp_(self):  # noqa
        with self._choice():
            with self._option():
                self._UppaalTCTLProp_()
            with self._option():
                self._UppaalSMCProp_()
            self._error('expecting one of: ! ( + - /[ \\t\\r\\n]*/ /[-+]?[0-9]*\\.[0-9]+([Ee][-+]?[0-9]+)?/ /[-+]?[0-9]+/ /[a-zA-Z_][a-zA-Z0-9_]*/ A Boolean Double E E[ HypothesisTest ID Integer Number Pr Predicate ProbCompare ProbEstimate PropAll PropExists PropLeadsTo PropPathQuant QBasicExpression QBinaryExpr QBracketExpr QDeadlock QExists QExpression QForAll QFuncCallExpr QSum QTernaryExpr QUnaryExpr Sim SimAcceptRuns SupInf Unary UppaalSMCProp UppaalTCTLProp Value ValueEstimate Variable _ deadlock exists false forall inf not simulate sum sup true')

    @tatsumasu()
    def _Clock_(self):  # noqa
        self._ID_()

    @tatsumasu()
    def _CONST_(self):  # noqa
        self._Value_()

    @tatsumasu()
    def _PROB_(self):  # noqa
        self._Value_()


class UppaalCLanguageSemantics(object): # pragma: no cover
    def _(self, ast):  # noqa
        return ast

    def __(self, ast):  # noqa
        return ast

    def UppaalDeclaration(self, ast):  # noqa
        return ast

    def UppaalSystemDeclaration(self, ast):  # noqa
        return ast

    def Declarations(self, ast):  # noqa
        return ast

    def Declaration(self, ast):  # noqa
        return ast

    def VariableDecls(self, ast):  # noqa
        return ast

    def VariableIDInit(self, ast):  # noqa
        return ast

    def VariableID(self, ast):  # noqa
        return ast

    def Initialiser(self, ast):  # noqa
        return ast

    def InitialiserArray(self, ast):  # noqa
        return ast

    def TypeDecls(self, ast):  # noqa
        return ast

    def Type(self, ast):  # noqa
        return ast

    def Prefix(self, ast):  # noqa
        return ast

    def BoundedIntType(self, ast):  # noqa
        return ast

    def ScalarType(self, ast):  # noqa
        return ast

    def StructType(self, ast):  # noqa
        return ast

    def TypeId(self, ast):  # noqa
        return ast

    def CustomType(self, ast):  # noqa
        return ast

    def FieldDecl(self, ast):  # noqa
        return ast

    def ArrayDecl(self, ast):  # noqa
        return ast

    def Function(self, ast):  # noqa
        return ast

    def Block(self, ast):  # noqa
        return ast

    def Statement(self, ast):  # noqa
        return ast

    def EmptyStatement(self, ast):  # noqa
        return ast

    def ExprStatement(self, ast):  # noqa
        return ast

    def ForLoop(self, ast):  # noqa
        return ast

    def Iteration(self, ast):  # noqa
        return ast

    def WhileLoop(self, ast):  # noqa
        return ast

    def DoWhileLoop(self, ast):  # noqa
        return ast

    def IfStatement(self, ast):  # noqa
        return ast

    def ReturnStatement(self, ast):  # noqa
        return ast

    def Parameters(self, ast):  # noqa
        return ast

    def Parameter(self, ast):  # noqa
        return ast

    def System(self, ast):  # noqa
        return ast

    def Process(self, ast):  # noqa
        return ast

    def Instantiation(self, ast):  # noqa
        return ast

    def ProgressDecl(self, ast):  # noqa
        return ast

    def NonTypeId(self, ast):  # noqa
        return ast

    def GanttDecl(self, ast):  # noqa
        return ast

    def GanttDef(self, ast):  # noqa
        return ast

    def GanttArgs(self, ast):  # noqa
        return ast

    def GanttEntryElem(self, ast):  # noqa
        return ast

    def GanttDeclSelect(self, ast):  # noqa
        return ast

    def GanttExprList(self, ast):  # noqa
        return ast

    def GantExprSingle(self, ast):  # noqa
        return ast

    def GanttExprSelect(self, ast):  # noqa
        return ast

    def GanttExpr(self, ast):  # noqa
        return ast

    def GanttEntrySelect(self, ast):  # noqa
        return ast

    def ChanPriority(self, ast):  # noqa
        return ast

    def ChanExpr(self, ast):  # noqa
        return ast

    def ChanDefault(self, ast):  # noqa
        return ast

    def VariableIndex(self, ast):  # noqa
        return ast

    def Variable(self, ast):  # noqa
        return ast

    def Integer(self, ast):  # noqa
        return ast

    def Double(self, ast):  # noqa
        return ast

    def Boolean(self, ast):  # noqa
        return ast

    def Number(self, ast):  # noqa
        return ast

    def Value(self, ast):  # noqa
        return ast

    def ID(self, ast):  # noqa
        return ast

    def TypeID(self, ast):  # noqa
        return ast

    def BracketExpr(self, ast):  # noqa
        return ast

    def DerivativeExpr(self, ast):  # noqa
        return ast

    def PostIncrAssignExpr(self, ast):  # noqa
        return ast

    def PostDecrAssignExpr(self, ast):  # noqa
        return ast

    def PreIncrAssignExpr(self, ast):  # noqa
        return ast

    def PreDecrAssignExpr(self, ast):  # noqa
        return ast

    def AssignExpr(self, ast):  # noqa
        return ast

    def FuncCallExpr(self, ast):  # noqa
        return ast

    def UnaryExpr(self, ast):  # noqa
        return ast

    def BinaryExpr(self, ast):  # noqa
        return ast

    def TernaryExpr(self, ast):  # noqa
        return ast

    def Deadlock(self, ast):  # noqa
        return ast

    def BasicExpression(self, ast):  # noqa
        return ast

    def Expression(self, ast):  # noqa
        return ast

    def Arguments(self, ast):  # noqa
        return ast

    def Assign(self, ast):  # noqa
        return ast

    def Unary(self, ast):  # noqa
        return ast

    def Binary(self, ast):  # noqa
        return ast

    def ForAll(self, ast):  # noqa
        return ast

    def Exists(self, ast):  # noqa
        return ast

    def Sum(self, ast):  # noqa
        return ast

    def ReservedTypeKeywords(self, ast):  # noqa
        return ast

    def ReservedQualKeywords(self, ast):  # noqa
        return ast

    def ReservedExprKeywords(self, ast):  # noqa
        return ast

    def ReservedStmtKeywords(self, ast):  # noqa
        return ast

    def ReservedOtherKeywords(self, ast):  # noqa
        return ast

    def ReservedFutureKeywords(self, ast):  # noqa
        return ast

    def ReservedNonTypeKeywords(self, ast):  # noqa
        return ast

    def ReservedKeywords(self, ast):  # noqa
        return ast

    def Invariant(self, ast):  # noqa
        return ast

    def Invariants(self, ast):  # noqa
        return ast

    def Select(self, ast):  # noqa
        return ast

    def Selects(self, ast):  # noqa
        return ast

    def Guard(self, ast):  # noqa
        return ast

    def Guards(self, ast):  # noqa
        return ast

    def Sync(self, ast):  # noqa
        return ast

    def Update(self, ast):  # noqa
        return ast

    def Updates(self, ast):  # noqa
        return ast

    def QBracketExpr(self, ast):  # noqa
        return ast

    def QFuncCallExpr(self, ast):  # noqa
        return ast

    def QUnaryExpr(self, ast):  # noqa
        return ast

    def QBinaryExpr(self, ast):  # noqa
        return ast

    def QTernaryExpr(self, ast):  # noqa
        return ast

    def QDeadlock(self, ast):  # noqa
        return ast

    def QForAll(self, ast):  # noqa
        return ast

    def QExists(self, ast):  # noqa
        return ast

    def QSum(self, ast):  # noqa
        return ast

    def QBasicExpression(self, ast):  # noqa
        return ast

    def QExpression(self, ast):  # noqa
        return ast

    def Predicate(self, ast):  # noqa
        return ast

    def PropAll(self, ast):  # noqa
        return ast

    def PropExists(self, ast):  # noqa
        return ast

    def PropLeadsTo(self, ast):  # noqa
        return ast

    def PropPathQuant(self, ast):  # noqa
        return ast

    def PropGlobally(self, ast):  # noqa
        return ast

    def PropFinally(self, ast):  # noqa
        return ast

    def PropUntil(self, ast):  # noqa
        return ast

    def PropPathSpecQuant(self, ast):  # noqa
        return ast

    def SupInf(self, ast):  # noqa
        return ast

    def TimeBound(self, ast):  # noqa
        return ast

    def Sim(self, ast):  # noqa
        return ast

    def SimAcceptRuns(self, ast):  # noqa
        return ast

    def ProbEstimate(self, ast):  # noqa
        return ast

    def HypothesisTest(self, ast):  # noqa
        return ast

    def ProbCompare(self, ast):  # noqa
        return ast

    def ValueEstimate(self, ast):  # noqa
        return ast

    def UppaalTCTLProp(self, ast):  # noqa
        return ast

    def UppaalSMCProp(self, ast):  # noqa
        return ast

    def UppaalProp(self, ast):  # noqa
        return ast

    def Clock(self, ast):  # noqa
        return ast

    def CONST(self, ast):  # noqa
        return ast

    def PROB(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs): # pragma: no cover
    if start is None:
        start = '_'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = UppaalCLanguageParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__': # pragma: no cover
    import json
    from tatsu.util import asjson

    ast = generic_main(main, UppaalCLanguageParser, name='UppaalCLanguage')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
